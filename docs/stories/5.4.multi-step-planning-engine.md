# Story 5.4: Multi-Step Planning and Execution Engine

## Status
Draft

## Story
**As an** analytical user,
**I want** systematic multi-step analysis planning,
**so that** complex queries are handled methodically rather than rushed.

## Acceptance Criteria
1. Estate Planner node that creates structured analysis plans for complex queries
2. Plan generation for different analysis types: prospect analysis, pattern analysis, competitive analysis
3. Dynamic plan adjustment based on intermediate results and discovered complexity
4. Task delegation to appropriate specialist agents with clear success criteria
5. Progress tracking and status updates during multi-step analysis execution
6. Error handling and plan revision when steps fail or produce insufficient results
7. Estimated completion times and resource requirements for analysis plans

## Tasks / Subtasks
- [ ] **Task 1: Estate Planner Node Implementation** (AC: 1)
  - [ ] Create EstatePlanner class for structured analysis planning
  - [ ] Implement query complexity assessment and decomposition
  - [ ] Add analysis plan template creation and management
  - [ ] Create plan optimization for efficiency and accuracy
  - [ ] Implement dependency graph creation for multi-step plans
  - [ ] Add resource requirement estimation for each plan step
  - [ ] Create plan validation and feasibility checking
  - [ ] Integrate with gatekeeper validation from Story 5.3

- [ ] **Task 2: Analysis Type Plan Templates** (AC: 2)
  - [ ] Create ProspectAnalysisPlan template for individual prospect deep dives
  - [ ] Implement PatternAnalysisPlan for cross-transcript pattern discovery
  - [ ] Add CompetitiveAnalysisPlan for win/loss and positioning analysis
  - [ ] Create PipelineAnalysisPlan for revenue and forecasting workflows
  - [ ] Implement PerformanceAnalysisPlan for rep and territory analysis
  - [ ] Add EnablementAnalysisPlan for content and training effectiveness
  - [ ] Create CustomAnalysisPlan for complex ad-hoc queries
  - [ ] Implement plan template selection based on query classification

- [ ] **Task 3: Dynamic Plan Adjustment System** (AC: 3)
  - [ ] Create PlanOptimizer class for runtime plan adaptation
  - [ ] Implement complexity detection from intermediate results
  - [ ] Add branch point creation for conditional analysis paths
  - [ ] Create plan expansion for discovered sub-questions
  - [ ] Implement plan pruning for irrelevant or redundant steps
  - [ ] Add parallel vs. sequential execution optimization
  - [ ] Create feedback loops for iterative refinement
  - [ ] Integrate with specialist agent performance metrics

- [ ] **Task 4: Task Delegation and Success Criteria** (AC: 4)
  - [ ] Create TaskDelegator class for agent assignment
  - [ ] Implement success criteria definition for each plan step
  - [ ] Add agent capability matching to task requirements
  - [ ] Create workload balancing across specialist agents
  - [ ] Implement priority-based task scheduling
  - [ ] Add dependency management for sequential tasks
  - [ ] Create fallback agent assignment for failures
  - [ ] Integrate with specialist agents from Story 5.2

- [ ] **Task 5: Progress Tracking and Status Updates** (AC: 5)
  - [ ] Create ExecutionTracker class for plan monitoring
  - [ ] Implement real-time progress tracking with step completion
  - [ ] Add estimated vs. actual time tracking
  - [ ] Create intermediate result collection and aggregation
  - [ ] Implement status update generation for user feedback
  - [ ] Add execution visualization for complex plans
  - [ ] Create checkpoint and recovery mechanisms
  - [ ] Integrate with Streamlit UI for progress display

- [ ] **Task 6: Error Handling and Plan Revision** (AC: 6)
  - [ ] Create PlanRecovery class for failure management
  - [ ] Implement error detection and classification
  - [ ] Add automatic plan revision for recoverable errors
  - [ ] Create alternative path generation for blocked steps
  - [ ] Implement partial result handling for incomplete steps
  - [ ] Add human-in-the-loop escalation for critical decisions
  - [ ] Create rollback mechanisms for failed analysis paths
  - [ ] Integrate with audit logging for failure analysis

- [ ] **Task 7: Resource Estimation and Management** (AC: 7)
  - [ ] Create ResourceEstimator class for plan costing
  - [ ] Implement execution time estimation per step
  - [ ] Add memory usage prediction for complex analyses
  - [ ] Create token usage estimation for LLM operations
  - [ ] Implement concurrent execution capacity planning
  - [ ] Add resource reservation and scheduling
  - [ ] Create resource optimization recommendations
  - [ ] Integrate with performance monitoring infrastructure

## Dev Notes

### Architecture Context
This story implements the intelligent planning layer that transforms ad-hoc queries into structured, methodical analysis plans. The Estate Planner ensures complex queries are decomposed, optimized, and executed systematically with specialist agents.

**Planning Engine Architecture:**
[Source: docs/prd.md#Epic 5 - Story 5.4]
- Structured decomposition of complex queries into executable steps
- Dynamic adaptation based on intermediate results
- Coordination of multiple specialist agents for comprehensive analysis
- Progress tracking and resource management for transparency

**Integration with Agentic RAG:**
[Source: architecture.md#Components - CrewAI Agent System]
- Works with gatekeeper (Story 5.3) for validated queries
- Coordinates specialist agents (Story 5.2) for execution
- Leverages enhanced knowledge base (Story 5.1) for context
- Provides input for quality assurance (Story 5.5)

### Estate Planner Implementation

**Planner Agent Definition:**
```python
estate_planner = Agent(
    role='Strategic Analysis Planner',
    goal='Create and optimize structured analysis plans for complex estate planning queries.',
    backstory="You are a master strategist who excels at breaking down complex analytical questions into methodical, step-by-step plans. You understand dependencies, optimize for efficiency, and adapt plans based on discoveries.",
    tools=[plan_creation_tool, complexity_assessment_tool, resource_estimation_tool],
    llm=AGENT_LLM,
    verbose=True
)
```

**Analysis Plan Structure:**
```python
class AnalysisPlan:
    def __init__(self, query: str, plan_type: str):
        self.query = query
        self.plan_type = plan_type
        self.steps = []
        self.dependencies = {}
        self.estimated_resources = {}
        self.success_criteria = {}
        self.status = "created"

    def add_step(self, step: PlanStep):
        self.steps.append(step)
        self._update_dependencies(step)
        self._estimate_step_resources(step)

class PlanStep:
    def __init__(self, step_id: str, description: str, agent: Agent):
        self.step_id = step_id
        self.description = description
        self.assigned_agent = agent
        self.dependencies = []
        self.success_criteria = {}
        self.estimated_duration = 0
        self.status = "pending"
        self.results = None
```

### Analysis Type Templates

**Prospect Analysis Plan Template:**
```python
class ProspectAnalysisPlan(AnalysisPlan):
    def __init__(self, prospect_name: str):
        super().__init__(f"Analyze prospect {prospect_name}", "prospect_analysis")
        self._build_prospect_plan(prospect_name)

    def _build_prospect_plan(self, prospect_name: str):
        # Step 1: Historical transcript retrieval
        self.add_step(PlanStep(
            "retrieve_history",
            f"Retrieve all transcripts and interactions for {prospect_name}",
            retrieval_agent
        ))

        # Step 2: Sales progression analysis
        self.add_step(PlanStep(
            "progression_analysis",
            "Analyze sales progression and deal momentum",
            revenue_ops_agent,
            dependencies=["retrieve_history"]
        ))

        # Step 3: Objection pattern analysis
        self.add_step(PlanStep(
            "objection_analysis",
            "Identify objections raised and resolution effectiveness",
            performance_analyst_agent,
            dependencies=["retrieve_history"]
        ))

        # Step 4: Competitive context
        self.add_step(PlanStep(
            "competitive_analysis",
            "Analyze competitive mentions and positioning",
            competitive_intel_agent,
            dependencies=["retrieve_history"]
        ))

        # Step 5: Strategic recommendations
        self.add_step(PlanStep(
            "recommendations",
            "Synthesize insights and generate action plan",
            estate_strategist_agent,
            dependencies=["progression_analysis", "objection_analysis", "competitive_analysis"]
        ))
```

**Pattern Analysis Plan Template:**
```python
class PatternAnalysisPlan(AnalysisPlan):
    def __init__(self, pattern_type: str, criteria: dict):
        super().__init__(f"Discover {pattern_type} patterns", "pattern_analysis")
        self._build_pattern_plan(pattern_type, criteria)

    def _build_pattern_plan(self, pattern_type: str, criteria: dict):
        # Multi-step pattern discovery workflow
        # 1. Data collection across transcripts
        # 2. Pattern identification and clustering
        # 3. Statistical validation
        # 4. Insight generation
        pass
```

### Dynamic Plan Adjustment

**Runtime Plan Optimization:**
```python
class PlanOptimizer:
    def __init__(self, plan: AnalysisPlan):
        self.plan = plan
        self.execution_history = []
        self.optimization_rules = self._load_optimization_rules()

    def adjust_plan(self, completed_step: PlanStep, results: dict):
        # Assess if plan needs adjustment based on results
        complexity_score = self._assess_result_complexity(results)

        if complexity_score > 0.8:
            # Expand plan with additional analysis steps
            additional_steps = self._generate_expansion_steps(results)
            self._insert_steps(additional_steps)

        elif self._has_insufficient_data(results):
            # Add data gathering steps
            data_steps = self._generate_data_collection_steps(results)
            self._insert_steps(data_steps)

        elif self._found_unexpected_patterns(results):
            # Branch into specialized analysis
            branch_steps = self._generate_branch_analysis(results)
            self._insert_steps(branch_steps)

    def optimize_execution_order(self):
        # Identify steps that can run in parallel
        parallel_groups = self._identify_parallel_opportunities()
        self._reorganize_for_parallel_execution(parallel_groups)
```

### Task Delegation Strategy

**Intelligent Task Assignment:**
```python
class TaskDelegator:
    def __init__(self, specialist_agents: dict):
        self.agents = specialist_agents
        self.agent_capabilities = self._map_agent_capabilities()
        self.workload_tracker = WorkloadTracker()

    def delegate_step(self, step: PlanStep) -> Agent:
        # Match step requirements to agent capabilities
        required_capabilities = self._extract_step_requirements(step)

        # Find best available agent
        candidates = self._find_capable_agents(required_capabilities)
        selected_agent = self._select_optimal_agent(candidates, step)

        # Track workload
        self.workload_tracker.assign_task(selected_agent, step)

        return selected_agent

    def define_success_criteria(self, step: PlanStep) -> dict:
        return {
            'completion_indicators': self._get_completion_indicators(step),
            'quality_thresholds': self._get_quality_thresholds(step),
            'output_requirements': self._get_output_requirements(step),
            'validation_rules': self._get_validation_rules(step)
        }
```

### Progress Tracking System

**Execution Monitoring:**
```python
class ExecutionTracker:
    def __init__(self, plan: AnalysisPlan):
        self.plan = plan
        self.start_time = None
        self.step_timings = {}
        self.intermediate_results = {}
        self.status_updates = []

    def start_execution(self):
        self.start_time = datetime.now()
        self.status_updates.append({
            'timestamp': self.start_time,
            'message': f"Started {self.plan.plan_type} analysis",
            'progress': 0
        })

    def track_step_progress(self, step: PlanStep, status: str, progress: float):
        self.step_timings[step.step_id] = {
            'start': step.start_time,
            'current': datetime.now(),
            'estimated_completion': self._estimate_completion(step),
            'status': status,
            'progress': progress
        }

        # Generate user-friendly status update
        update = self._generate_status_update(step, progress)
        self.status_updates.append(update)

    def get_overall_progress(self) -> float:
        completed_steps = len([s for s in self.plan.steps if s.status == "completed"])
        return completed_steps / len(self.plan.steps)
```

### Error Recovery Strategy

**Intelligent Plan Recovery:**
```python
class PlanRecovery:
    def __init__(self, plan: AnalysisPlan):
        self.plan = plan
        self.recovery_strategies = self._load_recovery_strategies()
        self.failure_history = []

    def handle_step_failure(self, failed_step: PlanStep, error: Exception):
        # Classify error type
        error_type = self._classify_error(error)

        # Determine recovery strategy
        if error_type == "data_unavailable":
            recovery = self._create_alternative_data_strategy(failed_step)
        elif error_type == "agent_timeout":
            recovery = self._create_simplified_analysis_strategy(failed_step)
        elif error_type == "validation_failure":
            recovery = self._create_relaxed_criteria_strategy(failed_step)
        else:
            recovery = self._create_fallback_strategy(failed_step)

        # Update plan with recovery steps
        self._apply_recovery_strategy(recovery)

        # Log failure for learning
        self.failure_history.append({
            'step': failed_step,
            'error': error,
            'recovery': recovery,
            'timestamp': datetime.now()
        })
```

### Resource Estimation

**Plan Resource Prediction:**
```python
class ResourceEstimator:
    def __init__(self):
        self.historical_metrics = self._load_historical_metrics()
        self.model_costs = self._load_model_costs()

    def estimate_plan_resources(self, plan: AnalysisPlan) -> dict:
        total_estimate = {
            'execution_time': 0,
            'memory_usage': 0,
            'token_usage': 0,
            'parallel_capacity': 0
        }

        for step in plan.steps:
            step_estimate = self._estimate_step_resources(step)
            total_estimate['execution_time'] += step_estimate['time']
            total_estimate['memory_usage'] = max(
                total_estimate['memory_usage'],
                step_estimate['memory']
            )
            total_estimate['token_usage'] += step_estimate['tokens']

        # Adjust for parallelization opportunities
        total_estimate['execution_time'] = self._adjust_for_parallelization(
            plan, total_estimate['execution_time']
        )

        return total_estimate
```

### Integration with UI

**Streamlit Progress Display:**
```python
def display_plan_execution(plan: AnalysisPlan, tracker: ExecutionTracker):
    # Display plan overview
    st.subheader(f"Executing {plan.plan_type} Analysis")

    # Progress bar
    progress = tracker.get_overall_progress()
    st.progress(progress)

    # Step status display
    for step in plan.steps:
        col1, col2, col3 = st.columns([3, 1, 1])
        with col1:
            st.text(step.description)
        with col2:
            st.text(step.status)
        with col3:
            if step.status == "running":
                st.spinner()

    # Estimated completion
    estimated_time = tracker.get_estimated_completion()
    st.info(f"Estimated completion: {estimated_time}")

    # Status updates
    with st.expander("Detailed Progress"):
        for update in tracker.status_updates[-5:]:  # Show last 5 updates
            st.text(f"{update['timestamp']}: {update['message']}")
```

### Testing Strategy

Unit tests should cover:
- Plan template creation and validation
- Dynamic plan adjustment logic
- Task delegation and agent selection
- Success criteria definition
- Resource estimation accuracy
- Error recovery strategies

Integration tests should verify:
- End-to-end plan execution with specialist agents
- Dynamic adjustment based on intermediate results
- Progress tracking and UI updates
- Error handling and recovery workflows
- Resource usage vs. estimates

Performance tests should validate:
- Plan optimization effectiveness
- Parallel execution improvements
- Resource estimation accuracy
- Recovery strategy success rates

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-19 | 1.0 | Initial story creation for multi-step planning and execution engine | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
N/A - Story in draft status

### Debug Log References
N/A - Implementation pending

### Completion Notes List
N/A - Implementation pending

### File List
N/A - Implementation pending

## QA Results
N/A - Story in draft status pending implementation