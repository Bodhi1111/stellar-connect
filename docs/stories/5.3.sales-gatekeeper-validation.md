# Story 5.3: Sales Gatekeeper and Query Validation System

## Status
Draft

## Story
**As a** sales leader and CRO,
**I want** intelligent sales query validation and clarification,
**so that** I receive precise revenue insights rather than vague or incomplete responses.

## Acceptance Criteria
1. Sales Gatekeeper node that validates queries for clarity, specificity, and actionability in sales/revenue context
2. Ambiguity detection for time periods, sales metrics, market segments, and competitive context requirements
3. Intelligent clarifying question generation when sales queries are unclear or incomplete
4. Query routing to appropriate sales specialist agents based on revenue analysis type and complexity
5. Context preservation for follow-up questions and sales query refinement
6. User-friendly clarification interface integrated with Streamlit chat for sales workflows
7. Performance optimization ensuring sales validation completes in <2 seconds

## Tasks / Subtasks
- [ ] **Task 1: Sales Gatekeeper Node Implementation** (AC: 1)
  - [ ] Create SalesGatekeeper class with query validation specialization
  - [ ] Implement sales context detection and classification algorithms
  - [ ] Add query clarity assessment using LLM-based analysis
  - [ ] Create specificity scoring for sales metrics and timeframes
  - [ ] Implement actionability assessment for revenue queries
  - [ ] Add domain validation for sales and revenue terminology
  - [ ] Create query categorization (pipeline, performance, competitive, enablement)
  - [ ] Integrate with existing CrewAI agent framework

- [ ] **Task 2: Ambiguity Detection System** (AC: 2)
  - [ ] Create AmbiguityDetector class for sales query analysis
  - [ ] Implement time period ambiguity detection (Q1, last month, recent)
  - [ ] Add sales metrics ambiguity identification (revenue, deals, conversion)
  - [ ] Create market segment ambiguity detection (territory, industry, size)
  - [ ] Implement competitive context requirement analysis
  - [ ] Add product/service specification ambiguity detection
  - [ ] Create team/individual scope ambiguity identification
  - [ ] Integrate with natural language processing for context analysis

- [ ] **Task 3: Intelligent Clarifying Question Generation** (AC: 3)
  - [ ] Create ClarificationGenerator class using sales domain knowledge
  - [ ] Implement time period clarification questions (specific dates, quarters)
  - [ ] Add metric definition clarification (which revenue, what conversion rate)
  - [ ] Create scope clarification questions (team, individual, territory)
  - [ ] Implement competitive context clarification (specific competitors)
  - [ ] Add data source clarification (which transcripts, time range)
  - [ ] Create priority and urgency clarification for complex queries
  - [ ] Integrate with LLM for contextual and natural question generation

- [ ] **Task 4: Query Routing and Agent Selection** (AC: 4)
  - [ ] Create QueryRouter class for specialist agent assignment
  - [ ] Implement query complexity assessment and agent selection
  - [ ] Add revenue operations routing logic (pipeline, forecasting)
  - [ ] Create performance analysis routing (rep analysis, coaching)
  - [ ] Implement competitive intelligence routing (win/loss, positioning)
  - [ ] Add sales enablement routing (content, training, methodology)
  - [ ] Create multi-agent routing for complex cross-functional queries
  - [ ] Integrate with specialist agents from Story 5.2

- [ ] **Task 5: Context Preservation and Query Refinement** (AC: 5)
  - [ ] Create QueryContext class for conversation state management
  - [ ] Implement context tracking across clarifying questions
  - [ ] Add query refinement through iterative clarification
  - [ ] Create context inheritance for follow-up questions
  - [ ] Implement conversation memory with sales context preservation
  - [ ] Add query intention tracking and evolution
  - [ ] Create context-aware clarification question generation
  - [ ] Integrate with Streamlit session state for conversation continuity

- [ ] **Task 6: Streamlit Integration and User Interface** (AC: 6)
  - [ ] Extend existing Streamlit chat interface with gatekeeper integration
  - [ ] Implement clarification question display and user response collection
  - [ ] Add query refinement workflow with iterative improvement
  - [ ] Create user-friendly clarification prompts and options
  - [ ] Implement quick selection options for common clarifications
  - [ ] Add query suggestion system for incomplete queries
  - [ ] Create validation feedback and query improvement guidance
  - [ ] Enhance app.py with gatekeeper workflow integration

- [ ] **Task 7: Performance Optimization and Response Time** (AC: 7)
  - [ ] Optimize gatekeeper validation for <2 second response time
  - [ ] Implement caching for common query patterns and validations
  - [ ] Add parallel processing for ambiguity detection and routing
  - [ ] Create efficient LLM prompt optimization for fast validation
  - [ ] Implement query pre-processing and pattern matching
  - [ ] Add performance monitoring and optimization feedback loops
  - [ ] Create timeout handling and graceful degradation
  - [ ] Integrate with existing performance monitoring infrastructure

## Dev Notes

### Architecture Context
This story implements the intelligent query validation layer that ensures users receive precise, actionable insights by clarifying ambiguous queries before processing. The gatekeeper acts as the first line of analysis, routing queries to appropriate specialist agents.

**Gatekeeper Architecture Pattern:**
[Source: docs/prd.md#Epic 5 - Story 5.3]
- Pre-processing layer before specialist agent analysis
- Query validation and clarification for precise results
- Intelligent routing to appropriate specialist agents
- Context preservation across clarifying conversations

**Integration with Agentic RAG:**
[Source: architecture.md#Components - CrewAI Agent System]
- Extends existing agent framework with validation layer
- Routes to specialist agents from Story 5.2
- Integrates with enhanced knowledge base from Story 5.1
- Maintains performance requirements with fast validation

### Sales Gatekeeper Implementation

**Gatekeeper Agent Definition:**
```python
sales_gatekeeper = Agent(
    role='Sales Query Validation Specialist',
    goal='Validate query clarity, detect ambiguities, and route to appropriate specialist agents.',
    backstory="You are an expert in sales and revenue operations who ensures every query receives the most precise and actionable response. You excel at identifying unclear queries and asking the right clarifying questions.",
    tools=[query_validation_tool, ambiguity_detection_tool, clarification_tool],
    llm=AGENT_LLM,
    verbose=True
)
```

**Query Validation Framework:**
```python
class SalesGatekeeper:
    def __init__(self, llm_model, specialist_agents):
        self.llm = llm_model
        self.agents = specialist_agents
        self.validation_criteria = self._load_sales_validation_rules()

    def validate_query(self, query: str, context: dict) -> ValidationResult:
        # Assess query clarity, specificity, and actionability
        clarity_score = self._assess_clarity(query)
        specificity_score = self._assess_specificity(query)
        actionability_score = self._assess_actionability(query)

        return ValidationResult(
            is_clear=clarity_score > 0.8,
            is_specific=specificity_score > 0.7,
            is_actionable=actionability_score > 0.7,
            required_clarifications=self._identify_clarifications(query)
        )

    def route_to_specialists(self, validated_query: str) -> List[Agent]:
        # Determine appropriate specialist agents for the query
        pass
```

### Ambiguity Detection System

**Sales-Specific Ambiguity Patterns:**
[Source: docs/prd.md#Epic 5 - Story 5.3]
- **Time Periods:** "recent", "last quarter", "this year" → specific dates
- **Sales Metrics:** "revenue", "deals", "conversion" → which specific metric
- **Market Segments:** "enterprise", "SMB", "territory" → specific definitions
- **Competitive Context:** "competitors", "market", "positioning" → specific companies
- **Team Scope:** "team", "reps", "organization" → specific individuals/groups

**Ambiguity Detection Implementation:**
```python
class AmbiguityDetector:
    def detect_ambiguities(self, query: str) -> List[Ambiguity]:
        ambiguities = []

        # Time period ambiguity
        if self._has_vague_timeframe(query):
            ambiguities.append(Ambiguity(
                type="time_period",
                detected_terms=self._extract_time_terms(query),
                clarification_needed="specific date range or time period"
            ))

        # Sales metric ambiguity
        if self._has_vague_metrics(query):
            ambiguities.append(Ambiguity(
                type="sales_metrics",
                detected_terms=self._extract_metric_terms(query),
                clarification_needed="specific metric definition"
            ))

        return ambiguities
```

### Clarification Question Generation

**Contextual Clarification Framework:**
```python
class ClarificationGenerator:
    def __init__(self, llm_model):
        self.llm = llm_model
        self.clarification_templates = self._load_templates()

    def generate_clarifications(self, ambiguities: List[Ambiguity], context: dict) -> List[str]:
        clarifications = []

        for ambiguity in ambiguities:
            if ambiguity.type == "time_period":
                clarifications.append(self._generate_time_clarification(ambiguity, context))
            elif ambiguity.type == "sales_metrics":
                clarifications.append(self._generate_metric_clarification(ambiguity, context))
            # ... other ambiguity types

        return clarifications

    def _generate_time_clarification(self, ambiguity: Ambiguity, context: dict) -> str:
        # Generate contextual time period clarification questions
        return f"Which specific time period? (e.g., Q4 2024, December 2024, last 30 days)"
```

### Query Routing Logic

**Specialist Agent Routing:**
[Source: architecture.md#Components - CrewAI Agent System]
```python
class QueryRouter:
    def __init__(self, specialist_agents):
        self.revenue_ops_agent = specialist_agents['revenue_ops']
        self.performance_agent = specialist_agents['performance']
        self.competitive_agent = specialist_agents['competitive']
        self.enablement_agent = specialist_agents['enablement']

    def route_query(self, validated_query: str) -> List[Agent]:
        query_type = self._classify_query(validated_query)

        routing_map = {
            'pipeline': [self.revenue_ops_agent],
            'forecasting': [self.revenue_ops_agent],
            'performance': [self.performance_agent],
            'coaching': [self.performance_agent],
            'competitive': [self.competitive_agent],
            'enablement': [self.enablement_agent],
            'complex': [self.revenue_ops_agent, self.performance_agent]
        }

        return routing_map.get(query_type, [self.revenue_ops_agent])
```

### Streamlit Integration

**Enhanced Chat Interface:**
[Source: architecture.md#Frontend Architecture]
```python
def handle_gatekeeper_workflow(user_query: str):
    # Validate query through gatekeeper
    validation_result = sales_gatekeeper.validate_query(user_query)

    if validation_result.needs_clarification:
        # Display clarifying questions
        clarifications = display_clarification_interface(validation_result.clarifications)

        # Collect user responses and refine query
        refined_query = refine_query_with_clarifications(user_query, clarifications)

        # Re-validate and route to specialists
        final_validation = sales_gatekeeper.validate_query(refined_query)
        selected_agents = sales_gatekeeper.route_to_specialists(refined_query)
    else:
        # Direct routing to appropriate specialists
        selected_agents = sales_gatekeeper.route_to_specialists(user_query)

    # Execute specialist analysis
    return execute_specialist_workflow(selected_agents, refined_query)
```

### Performance Optimization

**Sub-2-Second Validation Requirements:**
[Source: docs/prd.md#Epic 5 - Story 5.3]
- **Caching:** Common query patterns and validation results
- **Parallel Processing:** Ambiguity detection and routing in parallel
- **Optimized Prompts:** Efficient LLM prompts for fast validation
- **Pre-processing:** Pattern matching before LLM analysis
- **Timeout Handling:** Graceful degradation for complex queries

**Performance Monitoring:**
```python
class GatekeeperPerformanceMonitor:
    def __init__(self):
        self.validation_times = []
        self.cache_hit_rates = []
        self.routing_accuracy = []

    def track_validation_time(self, start_time: float, end_time: float):
        duration = end_time - start_time
        self.validation_times.append(duration)

        if duration > 2.0:
            logger.warning(f"Gatekeeper validation exceeded 2s: {duration:.2f}s")
```

### Context Preservation Strategy

**Conversation Context Management:**
[Source: architecture.md#Frontend Architecture - State Management]
```python
class QueryContext:
    def __init__(self):
        self.conversation_history = []
        self.clarification_history = []
        self.query_evolution = []
        self.specialist_assignments = []

    def add_clarification(self, clarification: str, response: str):
        self.clarification_history.append({
            'question': clarification,
            'response': response,
            'timestamp': datetime.now()
        })

    def preserve_context_for_followup(self, original_query: str, refined_query: str):
        self.query_evolution.append({
            'original': original_query,
            'refined': refined_query,
            'clarifications': self.clarification_history.copy()
        })
```

### Testing Strategy

Unit tests should cover:
- Query validation accuracy and scoring
- Ambiguity detection precision and recall
- Clarification question quality and relevance
- Query routing accuracy to appropriate specialists
- Performance optimization and response time requirements

Integration tests should verify:
- End-to-end gatekeeper workflow with Streamlit interface
- Context preservation across clarifying conversations
- Integration with specialist agents from Story 5.2
- Performance under various query types and complexities

User experience tests should validate:
- Clarification question clarity and usefulness
- Query refinement workflow usability
- Response time perception and user satisfaction
- Conversation flow and context preservation

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-19 | 1.0 | Initial story creation for sales gatekeeper and query validation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
N/A - Story in draft status

### Debug Log References
N/A - Implementation pending

### Completion Notes List
N/A - Implementation pending

### File List
N/A - Implementation pending

## QA Results
N/A - Story in draft status pending implementation